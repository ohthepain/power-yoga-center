/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Config_TYPES_H
#define Config_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace Yoga { namespace Config {

typedef int64_t Timestamp;

typedef std::string AssetID;

typedef int32_t SchemaVersionID;

typedef std::string PoseEntryID;

typedef std::string SessionID;

typedef std::string LocalizedString;

typedef std::string ResourceID;

typedef std::string UpgradeInfoID;

typedef std::vector<PoseEntryID>  PoseSequence;

class Settings;

class UpgradeInfo;

class PoseEntry;

class Session;

class Data;


class Settings : public virtual ::apache::thrift::TBase {
 public:

  Settings(const Settings&);
  Settings& operator=(const Settings&);
  Settings() : schemaVersionId(0), configVersionId(0), minClientVersion(), pleaseUpdateVersion() {
  }

  virtual ~Settings() throw();
  int32_t schemaVersionId;
  int32_t configVersionId;
  std::string minClientVersion;
  std::string pleaseUpdateVersion;

  void __set_schemaVersionId(const int32_t val);

  void __set_configVersionId(const int32_t val);

  void __set_minClientVersion(const std::string& val);

  void __set_pleaseUpdateVersion(const std::string& val);

  bool operator == (const Settings & rhs) const
  {
    if (!(schemaVersionId == rhs.schemaVersionId))
      return false;
    if (!(configVersionId == rhs.configVersionId))
      return false;
    if (!(minClientVersion == rhs.minClientVersion))
      return false;
    if (!(pleaseUpdateVersion == rhs.pleaseUpdateVersion))
      return false;
    return true;
  }
  bool operator != (const Settings &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Settings & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Settings &a, Settings &b);

std::ostream& operator<<(std::ostream& out, const Settings& obj);


class UpgradeInfo : public virtual ::apache::thrift::TBase {
 public:

  UpgradeInfo(const UpgradeInfo&);
  UpgradeInfo& operator=(const UpgradeInfo&);
  UpgradeInfo() : upgradeInfoId(), minClientVersion(), pleaseUpdateVersion() {
  }

  virtual ~UpgradeInfo() throw();
  UpgradeInfoID upgradeInfoId;
  std::string minClientVersion;
  std::string pleaseUpdateVersion;

  void __set_upgradeInfoId(const UpgradeInfoID& val);

  void __set_minClientVersion(const std::string& val);

  void __set_pleaseUpdateVersion(const std::string& val);

  bool operator == (const UpgradeInfo & rhs) const
  {
    if (!(upgradeInfoId == rhs.upgradeInfoId))
      return false;
    if (!(minClientVersion == rhs.minClientVersion))
      return false;
    if (!(pleaseUpdateVersion == rhs.pleaseUpdateVersion))
      return false;
    return true;
  }
  bool operator != (const UpgradeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UpgradeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UpgradeInfo &a, UpgradeInfo &b);

std::ostream& operator<<(std::ostream& out, const UpgradeInfo& obj);

typedef struct _PoseEntry__isset {
  _PoseEntry__isset() : flipped(false) {}
  bool flipped :1;
} _PoseEntry__isset;

class PoseEntry : public virtual ::apache::thrift::TBase {
 public:

  PoseEntry(const PoseEntry&);
  PoseEntry& operator=(const PoseEntry&);
  PoseEntry() : poseEntryId(), sessionId(), englishName(), sanskritName(), seconds(0), poseFilename(), backgroundFilename(), matFilename(), swooshFilename(), shadowFilename(), shortAudioFilename(), detailAudioFilename(), flipped(0) {
  }

  virtual ~PoseEntry() throw();
  PoseEntryID poseEntryId;
  SessionID sessionId;
  std::string englishName;
  std::string sanskritName;
  int32_t seconds;
  AssetID poseFilename;
  AssetID backgroundFilename;
  AssetID matFilename;
  AssetID swooshFilename;
  AssetID shadowFilename;
  AssetID shortAudioFilename;
  AssetID detailAudioFilename;
  bool flipped;

  _PoseEntry__isset __isset;

  void __set_poseEntryId(const PoseEntryID& val);

  void __set_sessionId(const SessionID& val);

  void __set_englishName(const std::string& val);

  void __set_sanskritName(const std::string& val);

  void __set_seconds(const int32_t val);

  void __set_poseFilename(const AssetID& val);

  void __set_backgroundFilename(const AssetID& val);

  void __set_matFilename(const AssetID& val);

  void __set_swooshFilename(const AssetID& val);

  void __set_shadowFilename(const AssetID& val);

  void __set_shortAudioFilename(const AssetID& val);

  void __set_detailAudioFilename(const AssetID& val);

  void __set_flipped(const bool val);

  bool operator == (const PoseEntry & rhs) const
  {
    if (!(poseEntryId == rhs.poseEntryId))
      return false;
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(englishName == rhs.englishName))
      return false;
    if (!(sanskritName == rhs.sanskritName))
      return false;
    if (!(seconds == rhs.seconds))
      return false;
    if (!(poseFilename == rhs.poseFilename))
      return false;
    if (!(backgroundFilename == rhs.backgroundFilename))
      return false;
    if (!(matFilename == rhs.matFilename))
      return false;
    if (!(swooshFilename == rhs.swooshFilename))
      return false;
    if (!(shadowFilename == rhs.shadowFilename))
      return false;
    if (!(shortAudioFilename == rhs.shortAudioFilename))
      return false;
    if (!(detailAudioFilename == rhs.detailAudioFilename))
      return false;
    if (__isset.flipped != rhs.__isset.flipped)
      return false;
    else if (__isset.flipped && !(flipped == rhs.flipped))
      return false;
    return true;
  }
  bool operator != (const PoseEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PoseEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PoseEntry &a, PoseEntry &b);

std::ostream& operator<<(std::ostream& out, const PoseEntry& obj);

typedef struct _Session__isset {
  _Session__isset() : subtitle(false), comingSoon(false), poses(false) {}
  bool subtitle :1;
  bool comingSoon :1;
  bool poses :1;
} _Session__isset;

class Session : public virtual ::apache::thrift::TBase {
 public:

  Session(const Session&);
  Session& operator=(const Session&);
  Session() : sessionId(), localizedName(), subtitle(), cardImage(), backgroundImage(), energyRating(0), comingSoon(0) {
  }

  virtual ~Session() throw();
  SessionID sessionId;
  LocalizedString localizedName;
  LocalizedString subtitle;
  ResourceID cardImage;
  ResourceID backgroundImage;
  int8_t energyRating;
  bool comingSoon;
  std::vector<PoseEntry>  poses;

  _Session__isset __isset;

  void __set_sessionId(const SessionID& val);

  void __set_localizedName(const LocalizedString& val);

  void __set_subtitle(const LocalizedString& val);

  void __set_cardImage(const ResourceID& val);

  void __set_backgroundImage(const ResourceID& val);

  void __set_energyRating(const int8_t val);

  void __set_comingSoon(const bool val);

  void __set_poses(const std::vector<PoseEntry> & val);

  bool operator == (const Session & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(localizedName == rhs.localizedName))
      return false;
    if (__isset.subtitle != rhs.__isset.subtitle)
      return false;
    else if (__isset.subtitle && !(subtitle == rhs.subtitle))
      return false;
    if (!(cardImage == rhs.cardImage))
      return false;
    if (!(backgroundImage == rhs.backgroundImage))
      return false;
    if (!(energyRating == rhs.energyRating))
      return false;
    if (__isset.comingSoon != rhs.__isset.comingSoon)
      return false;
    else if (__isset.comingSoon && !(comingSoon == rhs.comingSoon))
      return false;
    if (__isset.poses != rhs.__isset.poses)
      return false;
    else if (__isset.poses && !(poses == rhs.poses))
      return false;
    return true;
  }
  bool operator != (const Session &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Session & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Session &a, Session &b);

std::ostream& operator<<(std::ostream& out, const Session& obj);

typedef struct _Data__isset {
  _Data__isset() : poses(false), sessions(false) {}
  bool poses :1;
  bool sessions :1;
} _Data__isset;

class Data : public virtual ::apache::thrift::TBase {
 public:

  Data(const Data&);
  Data& operator=(const Data&);
  Data() : schemaVersionId(0) {
  }

  virtual ~Data() throw();
  SchemaVersionID schemaVersionId;
  std::vector<PoseEntry>  poses;
  std::vector<Session>  sessions;

  _Data__isset __isset;

  void __set_schemaVersionId(const SchemaVersionID val);

  void __set_poses(const std::vector<PoseEntry> & val);

  void __set_sessions(const std::vector<Session> & val);

  bool operator == (const Data & rhs) const
  {
    if (!(schemaVersionId == rhs.schemaVersionId))
      return false;
    if (__isset.poses != rhs.__isset.poses)
      return false;
    else if (__isset.poses && !(poses == rhs.poses))
      return false;
    if (__isset.sessions != rhs.__isset.sessions)
      return false;
    else if (__isset.sessions && !(sessions == rhs.sessions))
      return false;
    return true;
  }
  bool operator != (const Data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Data &a, Data &b);

std::ostream& operator<<(std::ostream& out, const Data& obj);

}} // namespace

#endif
